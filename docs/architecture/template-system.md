# Architecture: Template System

Deep dive into the Jinja2 template system for Dockerfile generation.

## Overview

The template system is the core of Absconda's flexibility, translating conda environment specifications into optimized Dockerfiles.

**Key features**:
- Jinja2-based templating
- Fragment composition
- Multiple deployment modes
- Template inheritance
- Custom template support

## Template Structure

### Directory Layout

```
src/absconda/_templates/
├── default/
│   ├── main.j2              # Entry point (selects fragment)
│   ├── Dockerfile.j2        # Main Dockerfile template
│   └── fragments/
│       ├── builder_stage.j2      # Multi-stage builder
│       ├── runtime_stage.j2      # Multi-stage runtime
│       ├── single_stage.j2       # Single-stage build
│       ├── export_block.j2       # Conda export logic
│       ├── requirements_runtime.j2   # Requirements mode
│       └── tarball_runtime.j2        # Tarball mode
```

### Template Hierarchy

```
User invokes build
    │
    ▼
Load main.j2
    │
    ├─► Dockerfile.j2 (base structure)
    │       │
    │       ├─► builder_stage.j2 (if multi-stage)
    │       │       │
    │       │       └─► export_block.j2
    │       │
    │       └─► runtime_stage.j2 (if multi-stage)
    │               │
    │               ├─► requirements_runtime.j2 (if requirements mode)
    │               └─► tarball_runtime.j2(if tarball mode)
    │
    └─► single_stage.j2 (if single-stage)
            │
            └─► (inline environment creation)
```

## Core Templates

### main.j2

Entry point that selects the appropriate build strategy:

```jinja2
{% raw %}
{# Main template router #}

{% set is_multi_stage = deploy_mode in ['requirements', 'export-explicit'] %}

{% if is_multi_stage %}
  {# Multi-stage build #}
  {% include 'fragments/builder_stage.j2' %}
  {% include 'fragments/runtime_stage.j2' %}
{% else %}
  {# Single-stage build #}
  {% include 'fragments/single_stage.j2' %}
{% endif %}
{% endraw %}
```

**Logic**:
- Determines single vs multi-stage based on `deploy_mode`
- Includes appropriate fragments
- Passes context to sub-templates

### Dockerfile.j2

Main structure template:

```jinja2
{% raw %}
# syntax=docker/dockerfile:1.4

#
# Conda environment: {{ name }}
# Generated by Absconda
#

{% if labels %}
# Labels
{% for key, value in labels.items() %}
LABEL {{ key }}="{{ value }}"
{% endfor %}
{% endif %}

{% block content %}
{# Filled by specific fragments #}
{% endblock %}

# Default command
{% if cmd %}
CMD {{ cmd }}
{% else %}
CMD ["{{ shell | default('/bin/bash') }}"]
{% endif %}
{% endraw %}
```

**Features**:
- Syntax declaration for BuildKit
- Metadata (labels)
- Block structure for inheritance
- Conditional default CMD

### builder_stage.j2

Multi-stage builder:

```jinja2
{% raw %}
# ============================================================================
# Stage 1: Builder
# ============================================================================
FROM {{ builder_base | default('mambaorg/micromamba:1.5.3') }} AS builder

USER root

# Install system dependencies
{% if system_packages %}
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
    {% for pkg in system_packages %}
    {{ pkg }} \
    {% endfor %}
    && rm -rf /var/lib/apt/lists/*
{% endif %}

USER $MAMBA_USER

# Copy environment file
COPY {{ env_filename }} /tmp/environment.yaml

# Create conda environment
RUN micromamba create -y -n {{ name }} -f /tmp/environment.yaml && \
    micromamba clean -afy

{% if deploy_mode == 'export-explicit' %}
# Export explicit requirements
{% include 'fragments/export_block.j2' %}
{% endif %}
{% endraw %}
```

**Responsibilities**:
- Set up builder environment
- Install build dependencies
- Create conda environment
- Export environment (if needed)
- Clean up to reduce layer size

### runtime_stage.j2

Multi-stage runtime:

```jinja2
{% raw %}
# ============================================================================
# Stage 2: Runtime
# ============================================================================
FROM {{ runtime_base | default('ubuntu:22.04') }}

# Install minimal runtime dependencies
{% if runtime_packages %}
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
    {% for pkg in runtime_packages %}
    {{ pkg }} \
    {% endfor %}
    && rm -rf /var/lib/apt/lists/*
{% endif %}

{% if deploy_mode == 'requirements' %}
{% include 'fragments/requirements_runtime.j2' %}
{% elif deploy_mode == 'tarball' %}
{% include 'fragments/tarball_runtime.j2' %}
{% else %}
# Copy full environment
COPY --from=builder /opt/conda/envs/{{ name }} /opt/conda/envs/{{ name }}
{% endif %}

# Environment variables
ENV PATH=/opt/conda/envs/{{ name }}/bin:$PATH
ENV CONDA_PREFIX=/opt/conda/envs/{{ name }}

{% if env_vars %}
{% for key, value in env_vars.items() %}
ENV {{ key }}="{{ value }}"
{% endfor %}
{% endif %}

# Create non-root user
RUN useradd -m -u 1000 appuser && \
    chown -R appuser:appuser /opt/conda/envs/{{ name }}

USER appuser
WORKDIR /app
{% endraw %}
```

**Responsibilities**:
- Minimal runtime base
- Install runtime-only dependencies
- Copy environment from builder
- Set up environment variables
- Create non-root user
- Security hardening

### single_stage.j2

Single-stage build (development):

```jinja2
{% raw %}
FROM {{ builder_base | default('mambaorg/micromamba:1.5.3') }}

USER root

# System dependencies
{% if system_packages %}
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
    {{ system_packages | join(' ') }} && \
    rm -rf /var/lib/apt/lists/*
{% endif %}

USER $MAMBA_USER

# Copy environment file
COPY {{ env_filename }} /tmp/environment.yaml

# Create environment
RUN micromamba create -y -n {{ name }} -f /tmp/environment.yaml && \
    micromamba clean -afy

# Activate environment
ENV PATH=/opt/conda/envs/{{ name }}/bin:$PATH
ENV CONDA_PREFIX=/opt/conda/envs/{{ name }}

WORKDIR /work
{% endraw %}
```

**Use case**: Development, Jupyter, RStudio (keep all tools)

## Fragment Templates

### export_block.j2

Exports environment for requirements mode:

```jinja2
{% raw %}
# Export environment to requirements
RUN micromamba run -n {{ name }} \
    conda list --export > /tmp/requirements.txt
{% endraw %}
```

### requirements_runtime.j2

Installs from exported requirements:

```jinja2
{% raw %}
# Install micromamba in runtime
RUN curl -Ls https://micro.mamba.pm/api/micromamba/linux-64/latest | \
    tar -xvj bin/micromamba

# Install from requirements
COPY --from=builder /tmp/requirements.txt /tmp/
RUN micromamba create -y -n {{ name }} --file /tmp/requirements.txt && \
    micromamba clean -afy && \
    rm /tmp/requirements.txt
{% endraw %}
```

**Benefits**:
- Only installs specified packages
- Smaller image size
- Faster installation

### tarball_runtime.j2

Unpacks tarball in runtime:

```jinja2
{% raw %}
# Create tarball in builder
# (This would be in builder_stage.j2)

# Unpack tarball in runtime
COPY --from=builder /tmp/env.tar.gz /tmp/
RUN mkdir -p /opt/conda/envs && \
    tar -xzf /tmp/env.tar.gz -C /opt/conda/envs/ && \
    rm /tmp/env.tar.gz
{% endraw %}
```

**Benefits**:
- Complete environment
- Fast unpacking
- No conda needed in runtime

## Deployment Modes

### Mode Selection Logic

```python
# In templates.py
def select_deployment_mode(env):
    """Determine deployment mode from environment."""
    
    # Explicit mode in YAML
    if env.deploy and env.deploy.mode:
        return env.deploy.mode
    
    # Infer from environment
    if env.is_production:
        return 'requirements'  # Optimized
    else:
        return 'full-env'  # Development
```

### Mode Comparison

| Mode | Image Size | Build Time | Use Case |
|------|-----------|-----------|----------|
| `full-env` | Largest | Fast | Development, interactive |
| `tarball` | Medium | Medium | Balanced |
| `requirements` | Small | Slow | Production |
| `export-explicit` | Smallest | Slowest | Minimal production |

### Full Environment Mode

```yaml
deploy:
  mode: full-env
```

**Template flow**:
```
single_stage.j2
    │
    └─► Create full conda environment
         Copy everything
         Large image (~2-3 GB)
```

### Tarball Mode

```yaml
deploy:
  mode: tarball
```

**Template flow**:
```
builder_stage.j2
    │
    ├─► Create environment
    ├─► Pack to tarball
    └─► Clean up
        │
        ▼
runtime_stage.j2
    │
    └─► Unpack tarball
         No conda in runtime
         Medium image (~1.5 GB)
```

### Requirements Mode

```yaml
deploy:
  mode: requirements
```

**Template flow**:
```
builder_stage.j2
    │
    ├─► Create environment
    ├─► Export requirements
    └─► Clean up
        │
        ▼
runtime_stage.j2
    │
    └─► Install from requirements
         Minimal conda in runtime
         Small image (~1 GB)
```

### Export Explicit Mode

```yaml
deploy:
  mode: export-explicit
```

**Template flow**:
```
builder_stage.j2
    │
    ├─► Create environment
    ├─► Export explicit (only requested packages)
    └─► Clean up
        │
        ▼
runtime_stage.j2
    │
    └─► Install explicit packages
         Minimal dependencies
         Smallest image (~800 MB)
```

## Custom Templates

### Template Context

Variables available in templates:

```python
context = {
    # Environment
    'name': 'myenv',
    'channels': ['conda-forge', 'defaults'],
    'dependencies': ['python=3.11', 'numpy'],
    
    # Metadata
    'labels': {'version': '1.0.0'},
    'env_vars': {'PYTHONUNBUFFERED': '1'},
    
    # Build configuration
    'builder_base': 'mambaorg/micromamba:1.5.3',
    'runtime_base': 'ubuntu:22.04',
    'deploy_mode': 'requirements',
    
    # Files
    'env_filename': 'environment.yaml',
    
    # System
    'system_packages': ['libgomp1'],
    'runtime_packages': ['ca-certificates'],
}
```

### Creating Custom Template

**Example: GPU template**

```jinja2
{% raw %}
# custom-gpu-template.j2

FROM nvidia/cuda:12.2.0-devel-ubuntu22.04 AS builder

# Install micromamba
RUN apt-get update && \
    apt-get install -y wget && \
    wget -qO- https://micro.mamba.pm/api/micromamba/linux-64/latest | \
    tar -xj -C / bin/micromamba

ENV MAMBA_ROOT_PREFIX=/opt/conda

# Create environment
COPY {{ env_filename }} /tmp/env.yaml
RUN micromamba create -y -n {{ name }} -f /tmp/env.yaml && \
    micromamba clean -afy

# Runtime with CUDA runtime
FROM nvidia/cuda:12.2.0-runtime-ubuntu22.04

COPY --from=builder /opt/conda/envs/{{ name }} /opt/conda/envs/{{ name }}

ENV PATH=/opt/conda/envs/{{ name }}/bin:$PATH
ENV CUDA_HOME=/usr/local/cuda
ENV LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH

# Labels
{% for key, value in labels.items() %}
LABEL {{ key }}="{{ value }}"
{% endfor %}

CMD ["python"]
{% endraw %}
```

**Usage**:

```bash
absconda generate \
  --file pytorch-env.yaml \
  --template custom-gpu-template.j2 \
  --output Dockerfile
```

### Template Best Practices

✅ **Do**:
- Use fragments for reusable components
- Include comments explaining logic
- Handle missing variables gracefully
- Provide sensible defaults
- Order layers by change frequency

❌ **Don't**:
- Hardcode values (use variables)
- Create deeply nested includes
- Duplicate logic across templates
- Ignore security (run as root, etc.)

## Template Inheritance

### Base Template

**`base.j2`**:

```jinja2
{% raw %}
FROM {{ base_image }}

{% block system_deps %}
# Override to add system dependencies
{% endblock %}

{% block conda_setup %}
# Default conda setup
COPY {{ env_filename }} /tmp/env.yaml
RUN micromamba create -y -n {{ name }} -f /tmp/env.yaml
{% endblock %}

{% block finalize %}
ENV PATH=/opt/conda/envs/{{ name }}/bin:$PATH
{% endblock %}
{% endraw %}
```

### Derived Template

**`myapp.j2`**:

```jinja2
{% raw %}
{% extends "base.j2" %}

{% block system_deps %}
RUN apt-get update && \
    apt-get install -y git curl && \
    rm -rf /var/lib/apt/lists/*
{% endblock %}

{% block finalize %}
{{ super() }}  # Call parent block
COPY app/ /app/
WORKDIR /app
{% endblock %}
{% endraw %}
```

## Template Testing

### Unit Tests

Test template rendering:

```python
# tests/test_templates.py

def test_single_stage_render():
    context = {
        'name': 'test-env',
        'env_filename': 'env.yaml',
        'builder_base': 'micromamba:1.5.3',
    }
    
    template = load_template('fragments/single_stage.j2')
    result = template.render(**context)
    
    assert 'FROM micromamba:1.5.3' in result
    assert 'test-env' in result
    assert 'env.yaml' in result
```

### Integration Tests

Test complete Dockerfile generation:

```python
def test_build_from_template():
    env = Environment.from_file('test-env.yaml')
    dockerfile = generate_dockerfile(env)
    
    # Write and build
    with open('Dockerfile.test', 'w') as f:
        f.write(dockerfile)
    
    result = subprocess.run(
        ['docker', 'build', '-f', 'Dockerfile.test', '-t', 'test:latest', '.'],
        capture_output=True
    )
    
    assert result.returncode == 0
```

## Template Debugging

### Enable Debug Output

```python
# In templates.py
import jinja2

env = jinja2.Environment(
    loader=jinja2.FileSystemLoader('templates'),
    trim_blocks=True,
    lstrip_blocks=True,
    undefined=jinja2.DebugUndefined,  # Show undefined variables
)
```

### Render to Stdout

```bash
# Generate without building
absconda generate \
  --file env.yaml \
  --output - | less
```

### Variable Inspection

Add to template:

```jinja2
{% raw %}
{# Debug: Print all context variables #}
{% for key, value in vars().items() %}
# {{ key }}: {{ value }}
{% endfor %}
{% endraw %}
```

## Performance Optimization

### Template Caching

```python
# Cache compiled templates
from jinja2 import Environment, FileSystemLoader, BytecodeCache
from jinja2.bccache import FileSystemBytecodeCache

cache = FileSystemBytecodeCache('/tmp/jinja_cache')
env = Environment(
    loader=FileSystemLoader('templates'),
    bytecode_cache=cache,
)
```

### Reduce Rendering Time

**Problem**: Complex templates take time to render

**Solutions**:
1. Cache compiled templates
2. Minimize conditional logic
3. Use fragments efficiently
4. Precompute values

## Common Patterns

### Conditional Blocks

```jinja2
{% raw %}
{% if gpu_support %}
FROM nvidia/cuda:12.2.0-runtime
{% else %}
FROM ubuntu:22.04
{% endif %}
{% endraw %}
```

### Loops

```jinja2
{% raw %}
{% for package in system_packages %}
{{ package }} \
{% endfor %}
{% endraw %}
```

### Filters

```jinja2
{% raw %}
# Join list
{{ packages | join(' ') }}

# Default value
{{ base_image | default('ubuntu:22.04') }}

# Upper case
{{ name | upper }}
{% endraw %}
```

### Macros

```jinja2
{% raw %}
{% macro install_system_pkg(packages) %}
RUN apt-get update && \
    apt-get install -y --no-install-recommends \
    {{ packages | join(' ') }} && \
    rm -rf /var/lib/apt/lists/*
{% endmacro %}

{{ install_system_pkg(['curl', 'git']) }}
{% endraw %}
```

## Future Enhancements

### Planned Features

1. **Template registry**: Share custom templates
2. **Template validation**: Check syntax before build
3. **Template variables**: User-defined substitutions
4. **Template composition**: Mix and match fragments
5. **Template versioning**: Lock template versions

### Experimental Ideas

1. **Visual template builder**: GUI for creating templates
2. **Template optimization**: Automatic layer ordering
3. **Template analysis**: Suggest improvements
4. **Template diff**: Compare templates side-by-side

## Related Documentation

- [Design Overview](design-overview.md) - Overall architecture
- [Requirements Mode Guide](../guides/requirements-mode.md) - Deployment modes
- [Building Images Guide](../guides/building-images.md) - Build process
- [Multi-Stage Builds How-to](../how-to/multi-stage-builds.md) - Optimization

## References

- **Jinja2 Documentation**: https://jinja.palletsprojects.com/
- **Docker Dockerfile Reference**: https://docs.docker.com/engine/reference/builder/
- **BuildKit Syntax**: https://github.com/moby/buildkit/blob/master/frontend/dockerfile/docs/syntax.md
